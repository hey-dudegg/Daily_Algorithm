#####################################
## 백준 1010
# 설명
# 강이 도시를 서부와 동부로 갈라놓고 있습니다.
# 서부와 동부에는 지점(사이트)들이 있으며, 도시의 발전을 위해 두 지점을 연결해야 합니다.
# 다리를 최대한 많이 짓기 위해, 서쪽의 지점만큼(N개)의 다리를 지으려고 합니다.
# 이때 다리를 짓는 경우의 수를 구하는 프로그램을 작성하세요.
# 한 지점에는 최대 한 개의 다리만 연결될 수 있으며, 다리끼리는 서로 겹쳐질 수 없습니다.

## 입력
# 입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트케이스에 대해 강의 서쪽과 동쪽에 있는 사이트의 개수
# 정수 N, M (0 < N ≤ M < 30)이 주어진다.

## 출력
# 각 테스트 케이스에 대해 주어진 조건하에 다리를 지을 수 있는 경우의 수를 출력한다.

## 문제 풀이
# 1. 서쪽에 6개, 동쪽에 10개의 지점이 있는 상황에서 서쪽의 중간(3번째라고 가정)의 지점을 동쪽의 중간(5번째라고 가정)에 연결한다면,
# 연결이 되지 않은 서쪽 1~2번째 지점은 동쪽 1~4번째 지점에 연결 가능하고, 서쪽 4~6번째 지점은 동쪽 6~10번째 지점에 연결 가능합니다.
# 이런식으로 두번째 다리를 놓고 세번째 다리를 놓을 때, 두번째 다리는 첫번째 다리를 놓는 경우에 따라 갈리게 됩니다. 
# 이후 마찬가지로 세번째도 두번째에 영향을 받습니다.
# 쉬운 예로, 이진트리에서의 DFS를 떠올리고 그 그림을 시계반대방향으로 90도 회전시킨 상황을 떠올리면 됩니다.
# 2. DFS를 구현하기 위해 DP로 구현합니다. 서쪽의 N개와 동쪽의 M개 만큼의 정수를 담은 리스트를 각각 생성합니다.
# 이후 DFS 함수를 활용하여 N개만큼 수행합니다..?
# DP에 대한 활용이 어려워서 DP 연습하고 다시 돌아오겠습니다.
#####################################
import sys
T = int(input())
input = sys.stdin.readline
result = 0

def dfs_recursive(list, start, cnt = 0):
    for node in list[start]:
        if node not in list:
            dfs_recursive(list, node, cnt)
    return cnt

for i in range(T):
    WestSite = []
    EastSite = []
    N, M = map(int, input().split())
    for j in range(1, N + 1):
        WestSite.append(j)
    for k in range(1, M + 1):
        EastSite.append(k)
    for l in range(1, N + 1):
        result += dfs_recursive(WestSite, l)
    print(result)